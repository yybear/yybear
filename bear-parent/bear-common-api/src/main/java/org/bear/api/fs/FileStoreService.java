/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
package org.bear.api.fs;

@SuppressWarnings("all")
@org.apache.avro.specific.AvroGenerated
public interface FileStoreService {
  public static final org.apache.avro.Protocol PROTOCOL = org.apache.avro.Protocol.parse("{\"protocol\":\"FileStoreService\",\"namespace\":\"org.bear.api.fs\",\"types\":[{\"type\":\"enum\",\"name\":\"Gender\",\"namespace\":\"org.bear.api.type\",\"doc\":\"\",\"symbols\":[\"UNKNOWN\",\"MALE\",\"FEMALE\"]},{\"type\":\"record\",\"name\":\"StackTrace\",\"namespace\":\"org.bear.api.type\",\"doc\":\"异常堆栈对象\",\"fields\":[{\"name\":\"className\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"doc\":\"发生异常的类\"},{\"name\":\"methodName\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"doc\":\"发生异常的方法\"},{\"name\":\"fileName\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"doc\":\"发生异常的文件\"},{\"name\":\"lineNumber\",\"type\":\"int\",\"doc\":\"发生异常的行号\"}]},{\"type\":\"enum\",\"name\":\"AccessScope\",\"namespace\":\"org.bear.api.type\",\"doc\":\"表示实体对象的访问权限级别\",\"symbols\":[\"ALL\",\"USER\",\"ROLE\",\"TOKEN\",\"SELF\",\"SESSION\"]},{\"type\":\"error\",\"name\":\"GlobalException\",\"namespace\":\"org.bear.api.type\",\"doc\":\"通用错误对象\",\"fields\":[{\"name\":\"code\",\"type\":\"int\",\"doc\":\"错误代码\"},{\"name\":\"msg\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"doc\":\"发生异常的方法\"},{\"name\":\"stackTraces\",\"type\":{\"type\":\"array\",\"items\":\"StackTrace\"},\"doc\":\"发生错误堆栈，供调试用\"}]},{\"type\":\"enum\",\"name\":\"Status\",\"namespace\":\"org.bear.api.type\",\"doc\":\"表示实体对象的状态\",\"symbols\":[\"ENABLED\",\"DISABLED\",\"DELETED\"]},{\"type\":\"enum\",\"name\":\"Operate\",\"doc\":\"* 表示支持的图片变换类型\\r\\n\\t *\\r\\n\\t * @field RESIZE 等比缩放\\r\\n\\t *\\r\\n\\t * @field CROP 裁剪\\r\\n\\t *\\r\\n\\t * @field ROTATE 旋转\",\"symbols\":[\"RESIZE\",\"CROP\",\"ROTATE\"]},{\"type\":\"record\",\"name\":\"File\",\"doc\":\"* 文件描述信息,通过主键或者业务加所有者即可获得所关联的文件信息\\r\\n\\t *\\r\\n\\t * @field id 文件的id,主键\\r\\n\\t *\\r\\n\\t * @field bizKey 文件所属的业务\\r\\n\\t *\\r\\n\\t * @field owner 文件的所有者,建议为业务对象的主键,这样配合bizKey就可以确定和这个业务对象向关联的所有文件\\r\\n\\t *\\r\\n\\t * @field userId 文件的关联用户,表示文件由哪个用户上传\\r\\n\\t *\\r\\n\\t * @field name 文件的名称\\r\\n\\t *\\r\\n\\t * @field size 文件的大小\\r\\n\\t *\\r\\n\\t * @field data 文件的附加属性\\r\\n\\t *\\r\\n\\t * @field updateAt 文件的最后更新时间\\r\\n\\t *\\r\\n\\t * @field scope 文件的访问权限级别\",\"fields\":[{\"name\":\"id\",\"type\":\"long\"},{\"name\":\"bizKey\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"owner\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"userId\",\"type\":\"long\"},{\"name\":\"name\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"size\",\"type\":\"int\"},{\"name\":\"data\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"avro.java.string\":\"String\"}},{\"name\":\"updateAt\",\"type\":\"long\"},{\"name\":\"scope\",\"type\":\"org.bear.api.type.AccessScope\"}]},{\"type\":\"record\",\"name\":\"FilePage\",\"doc\":\"* 文件列表分页对象\\r\\n\\t *\\r\\n\\t * @field items 文件列表\\r\\n\\t *\\r\\n\\t * @field total 文件总数\",\"fields\":[{\"name\":\"items\",\"type\":{\"type\":\"array\",\"items\":\"File\"}},{\"name\":\"total\",\"type\":\"int\"}]},{\"type\":\"record\",\"name\":\"Action\",\"doc\":\"* 图片变换操作\\r\\n\\t *\\r\\n\\t * @field operate 操作类型\\r\\n\\t *\\r\\n\\t * @field params 附加参数\",\"fields\":[{\"name\":\"operate\",\"type\":\"Operate\"},{\"name\":\"param\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"avro.java.string\":\"String\"}}]}],\"messages\":{\"saveFile\":{\"doc\":\"* 保存一个文件,当id为空时则为新建\\r\\n     * \\r\\n     * 1. 若id不为空,获取id对应的file对象,设置传入的新属性后更新 (可更新owner,userId,name,scope,data属性)\\r\\n     * 2. 若id为空,则新建一个file对象\\r\\n     *\\r\\n     * @param file 待保存的文件信\\r\\n     *\\r\\n     * @return 包含id的文件\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"file\",\"type\":\"File\"}],\"response\":\"File\",\"errors\":[\"org.bear.api.type.GlobalException\"]},\"removeFiles\":{\"doc\":\"* 批量删除文件\\r\\n     * 1. 批量将对应的数据库记录的status属性设置成Status.DELETED(逻辑删除)\\r\\n     * 2. 真实文件不做删除\\r\\n     * \\r\\n     * @param ids 文件id列表\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"ids\",\"type\":{\"type\":\"array\",\"items\":\"long\"}}],\"response\":\"null\",\"errors\":[\"org.bear.api.type.GlobalException\"]},\"removeFilesByOwner\":{\"doc\":\"* 批量删除和某个所有者相关联的所有文件\\r\\n     * 1. 批量将对应的数据库记录的status属性设置成Status.DELETED(逻辑删除)\\r\\n     * 2. 真实文件不做删除\\r\\n     * \\r\\n     * @param bizKey 业务名\\r\\n     *\\r\\n     * @param owner 所有者\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"bizKey\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"owner\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}}],\"response\":\"null\",\"errors\":[\"org.bear.api.type.GlobalException\"]},\"writeFile\":{\"doc\":\"* 将二进制内容写入到目标文件的指定位置\\r\\n     * \\r\\n     * 1. 根据文件编号获取数据库中的文件记录\\r\\n     * 2. 根据文件选择存储对象(storage)\\r\\n     * \\t  2.1 file对象获取storage属性值(系统在初始化时默认配置了唯一一个id为s1的sanyuan.any123.filestore.fs.FileSystemStorage,它的capability=-1,enable=true,存储基本路径directory配置为application.properties的storage1.path)\\r\\n     *        若属性值未设置,遍历已有的storages列表,如果storage.isAvailable(如果是enable且,capability小于0或used大于capability),则选择这个storage\\r\\n     *        若属性值已设置(该值可以为多个存储id以逗号分隔连接而成),则分隔成id列表,遍历已有storages的map(key为storage的id,value为storage),匹配第一个有效的storage(同上storage.isAvaliable)\\r\\n     * 3. 获取file的key(fs-加上文件编号)\\r\\n     * 4. 把这个key进行md5加密,'加密结果前两位/加密结果第三、四位/加密结果',作为文件的子路径\\r\\n     * 5. 如果storage配置了useXsendfile为true的话,子路径前加上'/文件编号/'组成xpath\\r\\n     * 6. 检查并创建这个文件\\r\\n     * \\t  6.1 若该路径下文件已存在,则跳过\\r\\n     *    6.2 若文件不存在,检查并创建父文件路径,创建该文件\\r\\n     * 7. 写入从起始位置开始,写入一定长度的二进制文件\\r\\n     * 8. 文件设置大小信息\\r\\n     * 9. 更新数据库中的文件信息\\r\\n     *  \\r\\n     * @param id 文件id\\r\\n     *\\r\\n     * @param binary 二进制内容\\r\\n     *\\r\\n     * @param position 起始位置\\r\\n     *\\r\\n     * @param binary 二进制内容\\r\\n     *\\r\\n     * @throws FsException <ul>\\r\\n     *     <li>201 io错误</li>\\r\\n     *     <li>202 文件未找到</li>\\r\\n     * </ul>\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"id\",\"type\":\"long\"},{\"name\":\"bytes\",\"type\":\"bytes\"},{\"name\":\"position\",\"type\":\"int\"}],\"response\":\"null\",\"errors\":[\"org.bear.api.type.GlobalException\"]},\"readFile\":{\"doc\":\"* 从目标文件中读取内容\\r\\n     * \\r\\n     * 1. 同writeFile逻辑一致,获取文件存放路径\\r\\n     * 2. 根据路径找到文件,读取文件起始位置开始,一定长度的二进制流\\r\\n     * \\r\\n     *\\r\\n     * @param id 文件id\\r\\n     *\\r\\n     * @param position 起始位置\\r\\n     *\\r\\n     * @param count 要读取的长度\\r\\n     *\\r\\n     * @return 读取的二进制内容\\r\\n     *\\r\\n     * @throws FsException <ul>\\r\\n     *     <li>201 io错误</li>\\r\\n     *     <li>202 文件未找到</li>\\r\\n     * </ul>\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"id\",\"type\":\"long\"},{\"name\":\"position\",\"type\":\"int\"},{\"name\":\"count\",\"type\":\"int\"}],\"response\":\"bytes\",\"errors\":[\"org.bear.api.type.GlobalException\"]},\"transformImage\":{\"doc\":\"* 变换一个图片\\r\\n     *  \\r\\n     * 涉及到的参数\\r\\n     * \\r\\n     *  \\r\\n     * 1. 同writeFile逻辑一致,获取文件存放路径\\r\\n     * 2. 如果文件是图片(后缀为\\\"gif\\\", \\\"bmp\\\", \\\"jpg\\\", \\\"jpeg\\\", \\\"png\\\"之一),则进行后续操作(本系统由AwtImageTransform进行图片相关操作)\\r\\n     * 3. 若操作为缩放,则调用图片缩放接口,由宽度为限制条件(若实际图片宽度>目标宽度,则缩放比例为目标宽度/实际宽度),等比缩放\\r\\n     * 4. 若操作为裁剪,则调用图片裁剪接口,截取从图片左上角为坐标轴原点,第四象限中(left,-top)这个点为起点,x轴正方向width宽度,y轴反方向height高度组成的矩形\\r\\n     * 5. 若操作为翻转,则选取从图片左上角为坐标轴原点,第四象限中(left,-top)这个点为旋转中心点,以逆时针方向旋转一定角度\\r\\n     * 6. 操作完成后,更新数据库中文件的大小\\r\\n     * \\r\\n     * @param id 文件id\\r\\n     *\\r\\n     * @param actions 变换操作列表\\r\\n     *\\r\\n     * @tables fs_file\\r\\n     *\",\"request\":[{\"name\":\"id\",\"type\":\"long\"},{\"name\":\"actions\",\"type\":{\"type\":\"array\",\"items\":\"Action\"}}],\"response\":\"null\",\"errors\":[\"org.bear.api.type.GlobalException\"]},\"getToken\":{\"doc\":\"* 获取一个文件的访问token,通过url携带这个token实现文件的自定义权限\\r\\n     * 1. 用tokenService创建一个有效期为ttl的token (详见tokenService的createTokenEx)\\r\\n     * 2. 用tokenService在该token上绑定参数列表 (详见tokenService的bindListParam)\\r\\n     *    2.1 多个id\\r\\n     *    2.2 若可写,参数加上true\\r\\n     * 3. 返回该token\\r\\n     * \\r\\n     * @param ids 文件id\\r\\n     *\\r\\n     * @param writeable 是否可写\\r\\n     *\\r\\n     * @param ttl token的有效时间,单位秒\\r\\n     *\\r\\n     * @return token字符串\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"ids\",\"type\":{\"type\":\"array\",\"items\":\"long\"}},{\"name\":\"writeable\",\"type\":\"boolean\"},{\"name\":\"ttl\",\"type\":\"int\"}],\"response\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"errors\":[\"org.bear.api.type.GlobalException\"]},\"getBizToken\":{\"doc\":\"* 获取业务文件的访问token,通过url携带这个token实现文件的自定义权限\\r\\n     *\\r\\n     * 1. 用tokenService创建一个有效期为ttl的token (详见tokenService的createTokenEx)\\r\\n     * 2. 用tokenService在该token上绑定参数列表 (详见tokenService的bindListParam)\\r\\n     *    2.1 多个owner\\r\\n     *    2.2 若可写,参数加上true\\r\\n     * 3. 返回该token\\r\\n     *\\r\\n     * @param bizKey 业务名\\r\\n     *\\r\\n     * @param owners 所有者列表\\r\\n     *\\r\\n     * @param writeable 是否可写\\r\\n     *\\r\\n     * @param ttl token的有效时间,单位秒\\r\\n     *\\r\\n     * @return 业务token字符串\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"bizKey\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"owners\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"string\",\"avro.java.string\":\"String\"}}},{\"name\":\"writeable\",\"type\":\"boolean\"},{\"name\":\"ttl\",\"type\":\"int\"}],\"response\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"errors\":[\"org.bear.api.type.GlobalException\"]},\"bindSession\":{\"doc\":\"* 绑定文件的读取权限到会话session\\r\\n     * 1.遍历文件编号,将他们以 'fs'+文件编号 为key,'T'为value放入一个map\\r\\n     * 2.调用identityService的setSessionAttributes方法进行绑定(详见identityService)\\r\\n     *\\r\\n     * @param sessionId 会话id\\r\\n     *\\r\\n     * @param ids 文件id列表\",\"request\":[{\"name\":\"sessionId\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"ids\",\"type\":{\"type\":\"array\",\"items\":\"long\"}}],\"response\":\"null\",\"errors\":[\"org.bear.api.type.GlobalException\"]},\"unbindSession\":{\"doc\":\"* 取消绑定文件的读取权限到会话session\\r\\n     * \\r\\n     * 1.遍历文件编号,将他们以 'fs'+文件编号 为key,'T'为value放入一个map\\r\\n     * 2.调用identityService的removeSessionAttributes方法取消绑定(详见identityService)\\r\\n     * \\r\\n     * @param sessionId 会话id\\r\\n     *\\r\\n     * @param ids 文件id列表\",\"request\":[{\"name\":\"sessionId\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"ids\",\"type\":{\"type\":\"array\",\"items\":\"long\"}}],\"response\":\"null\",\"errors\":[\"org.bear.api.type.GlobalException\"]},\"getFile\":{\"doc\":\"* 获取一个文件\\r\\n     * \\r\\n     * 1.仅获取数据库中的一个文件对象\\r\\n     *\\r\\n     * @param id 文件id\\r\\n     *\\r\\n     * @return 文件\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"id\",\"type\":\"long\"}],\"response\":\"File\",\"errors\":[\"org.bear.api.type.GlobalException\"]},\"getFileMap\":{\"doc\":\"* 根据id批量获取文件\\r\\n     * \\r\\n     * @param id 文件id列表\\r\\n     *\\r\\n     * @return 文件map\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"ids\",\"type\":{\"type\":\"array\",\"items\":\"long\"}}],\"response\":{\"type\":\"map\",\"values\":\"File\",\"avro.java.string\":\"String\"},\"errors\":[\"org.bear.api.type.GlobalException\"]},\"getSingleFile\":{\"doc\":\"* 获取某个业务对象关联的文件\\r\\n     * 例如用户的头像可以用getSingleFile(SPACE_AVATAR, \\\"888\\\")来获取888用户的头像文件信息\\r\\n     *\\r\\n     * @param bizKey 业务名\\r\\n     *\\r\\n     * @param owner 所有者\\r\\n     *\\r\\n     * @return 文件\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"bizKey\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"owner\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}}],\"response\":\"File\",\"errors\":[\"org.bear.api.type.GlobalException\"]},\"getFiles\":{\"doc\":\"* 获取某个业务对象关联的文件,例如要获取某个帖子相关的附件,,按文件上传倒序排序\\r\\n     *\\r\\n     * @param bizKey 业务名\\r\\n     *\\r\\n     * @param owner 所有者\\r\\n     *\\r\\n     * @return 文件列表\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"bizKey\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"owner\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}}],\"response\":{\"type\":\"array\",\"items\":\"File\"},\"errors\":[\"org.bear.api.type.GlobalException\"]},\"batchGetFiles\":{\"doc\":\"* 根据owner列表批量获取某个业务对象关联的文件\\r\\n     *\\r\\n     * @param bizKey 业务名\\r\\n     *\\r\\n     * @param owners 所有者列表\\r\\n     *\\r\\n     * @return 文件列表map\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"bizKey\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"owners\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"string\",\"avro.java.string\":\"String\"}}}],\"response\":{\"type\":\"map\",\"values\":{\"type\":\"array\",\"items\":\"File\"},\"avro.java.string\":\"String\"},\"errors\":[\"org.bear.api.type.GlobalException\"]},\"batchGetFilesEx\":{\"doc\":\"* 根据多个bizKey,多个owner获取文件,格式map<bizKey, set<owner>>\\r\\n     *\\r\\n     * @param ownersMap 嵌套map,map<bizKey, set<owner>>\\r\\n     *\\r\\n     * @param owners 所有者列表\\r\\n     *\\r\\n     * @return 嵌套map,map<bizKey, map<owner, list<File>>>\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"ownersMap\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"array\",\"items\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},\"avro.java.string\":\"String\"}}],\"response\":{\"type\":\"map\",\"values\":{\"type\":\"map\",\"values\":{\"type\":\"array\",\"items\":\"File\"},\"avro.java.string\":\"String\"},\"avro.java.string\":\"String\"},\"errors\":[\"org.bear.api.type.GlobalException\"]},\"getEncryptedId\":{\"doc\":\"* 获取某个文件的加密访问id\\r\\n     * \\r\\n     * 1. 将id和系统时间和有效期,以某种形式组合,并通过加密算法加密后形成的字符串\\r\\n     * \\r\\n     * @param id 文件id\\r\\n     *\\r\\n     * @param ttl 加密id的有效时间,单位秒，0为不限制\\r\\n     *\\r\\n     * @return 加密的id\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"id\",\"type\":\"long\"},{\"name\":\"ttl\",\"type\":\"int\"}],\"response\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"errors\":[\"org.bear.api.type.GlobalException\"]},\"getEncryptedIds\":{\"doc\":\"* 批量获取文件的加密访问\\r\\n     * \\r\\n     * 1.同getEncryptedId\\r\\n     * \\r\\n     * @param ids 文件id列表\\r\\n     *\\r\\n     * @param ttl 加密id的有效时间,单位秒，0为不限制\\r\\n     *\\r\\n     * @return 加密的id列表\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"ids\",\"type\":{\"type\":\"array\",\"items\":\"long\"}},{\"name\":\"ttl\",\"type\":\"int\"}],\"response\":{\"type\":\"map\",\"values\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"avro.java.string\":\"String\"},\"errors\":[\"org.bear.api.type.GlobalException\"]},\"getFileByEncryptedId\":{\"doc\":\"* 根据加密的id获取文件\\r\\n     * \\r\\n     * 1. 根据加密规则解密出文件编号\\r\\n     * 2. 根据文件编号从数据库中获取文件对象\\r\\n     *\\r\\n     * @param encryptedId 加密的id\\r\\n     *\\r\\n     * @return 文件\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"encryptedId\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}}],\"response\":\"File\",\"errors\":[\"org.bear.api.type.GlobalException\"]},\"getFileMapByEncryptedId\":{\"doc\":\"* 批量根据加密的id获取文件\\r\\n     * \\r\\n     * 1.同getFileByEncryptedId\\r\\n     *\\r\\n     * @param encryptedIds 加密的id列表\\r\\n     *\\r\\n     * @return 文件map\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"encryptedIds\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"string\",\"avro.java.string\":\"String\"}}}],\"response\":{\"type\":\"map\",\"values\":\"File\",\"avro.java.string\":\"String\"},\"errors\":[\"org.bear.api.type.GlobalException\"]},\"getUserFiles\":{\"doc\":\"* 获取某个用户在目标业务的所有文件,如果业务为空则返回所有业务文件,按文件上传倒序排序\\r\\n     *\\r\\n     * @param bizKey 业务名 为空则忽略此条件\\r\\n     *\\r\\n     * @param owner 所有者 为空则忽略此条件\\r\\n     *\\r\\n     * @param userId 用户id\\r\\n     *\\r\\n     * @param start 开始位置\\r\\n     *\\r\\n     * @param size 获取个数\\r\\n     *\\r\\n     * @return 文件列表分页对象\\r\\n     *\\r\\n     * @tables fs_file\",\"request\":[{\"name\":\"bizKey\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"owner\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"userId\",\"type\":\"long\"},{\"name\":\"start\",\"type\":\"int\"},{\"name\":\"size\",\"type\":\"int\"}],\"response\":\"FilePage\",\"errors\":[\"org.bear.api.type.GlobalException\"]}}}");
  /** * 保存一个文件,当id为空时则为新建
     * 
     * 1. 若id不为空,获取id对应的file对象,设置传入的新属性后更新 (可更新owner,userId,name,scope,data属性)
     * 2. 若id为空,则新建一个file对象
     *
     * @param file 待保存的文件信
     *
     * @return 包含id的文件
     *
     * @tables fs_file */
  org.bear.api.fs.File saveFile(org.bear.api.fs.File file) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 批量删除文件
     * 1. 批量将对应的数据库记录的status属性设置成Status.DELETED(逻辑删除)
     * 2. 真实文件不做删除
     * 
     * @param ids 文件id列表
     *
     * @tables fs_file */
  java.lang.Void removeFiles(java.util.List<java.lang.Long> ids) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 批量删除和某个所有者相关联的所有文件
     * 1. 批量将对应的数据库记录的status属性设置成Status.DELETED(逻辑删除)
     * 2. 真实文件不做删除
     * 
     * @param bizKey 业务名
     *
     * @param owner 所有者
     *
     * @tables fs_file */
  java.lang.Void removeFilesByOwner(java.lang.String bizKey, java.lang.String owner) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 将二进制内容写入到目标文件的指定位置
     * 
     * 1. 根据文件编号获取数据库中的文件记录
     * 2. 根据文件选择存储对象(storage)
     * 	  2.1 file对象获取storage属性值(系统在初始化时默认配置了唯一一个id为s1的sanyuan.any123.filestore.fs.FileSystemStorage,它的capability=-1,enable=true,存储基本路径directory配置为application.properties的storage1.path)
     *        若属性值未设置,遍历已有的storages列表,如果storage.isAvailable(如果是enable且,capability小于0或used大于capability),则选择这个storage
     *        若属性值已设置(该值可以为多个存储id以逗号分隔连接而成),则分隔成id列表,遍历已有storages的map(key为storage的id,value为storage),匹配第一个有效的storage(同上storage.isAvaliable)
     * 3. 获取file的key(fs-加上文件编号)
     * 4. 把这个key进行md5加密,'加密结果前两位/加密结果第三、四位/加密结果',作为文件的子路径
     * 5. 如果storage配置了useXsendfile为true的话,子路径前加上'/文件编号/'组成xpath
     * 6. 检查并创建这个文件
     * 	  6.1 若该路径下文件已存在,则跳过
     *    6.2 若文件不存在,检查并创建父文件路径,创建该文件
     * 7. 写入从起始位置开始,写入一定长度的二进制文件
     * 8. 文件设置大小信息
     * 9. 更新数据库中的文件信息
     *  
     * @param id 文件id
     *
     * @param binary 二进制内容
     *
     * @param position 起始位置
     *
     * @param binary 二进制内容
     *
     * @throws FsException <ul>
     *     <li>201 io错误</li>
     *     <li>202 文件未找到</li>
     * </ul>
     *
     * @tables fs_file */
  java.lang.Void writeFile(long id, java.nio.ByteBuffer bytes, int position) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 从目标文件中读取内容
     * 
     * 1. 同writeFile逻辑一致,获取文件存放路径
     * 2. 根据路径找到文件,读取文件起始位置开始,一定长度的二进制流
     * 
     *
     * @param id 文件id
     *
     * @param position 起始位置
     *
     * @param count 要读取的长度
     *
     * @return 读取的二进制内容
     *
     * @throws FsException <ul>
     *     <li>201 io错误</li>
     *     <li>202 文件未找到</li>
     * </ul>
     *
     * @tables fs_file */
  java.nio.ByteBuffer readFile(long id, int position, int count) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 变换一个图片
     *  
     * 涉及到的参数
     * 
     *  
     * 1. 同writeFile逻辑一致,获取文件存放路径
     * 2. 如果文件是图片(后缀为"gif", "bmp", "jpg", "jpeg", "png"之一),则进行后续操作(本系统由AwtImageTransform进行图片相关操作)
     * 3. 若操作为缩放,则调用图片缩放接口,由宽度为限制条件(若实际图片宽度>目标宽度,则缩放比例为目标宽度/实际宽度),等比缩放
     * 4. 若操作为裁剪,则调用图片裁剪接口,截取从图片左上角为坐标轴原点,第四象限中(left,-top)这个点为起点,x轴正方向width宽度,y轴反方向height高度组成的矩形
     * 5. 若操作为翻转,则选取从图片左上角为坐标轴原点,第四象限中(left,-top)这个点为旋转中心点,以逆时针方向旋转一定角度
     * 6. 操作完成后,更新数据库中文件的大小
     * 
     * @param id 文件id
     *
     * @param actions 变换操作列表
     *
     * @tables fs_file
     * */
  java.lang.Void transformImage(long id, java.util.List<org.bear.api.fs.Action> actions) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 获取一个文件的访问token,通过url携带这个token实现文件的自定义权限
     * 1. 用tokenService创建一个有效期为ttl的token (详见tokenService的createTokenEx)
     * 2. 用tokenService在该token上绑定参数列表 (详见tokenService的bindListParam)
     *    2.1 多个id
     *    2.2 若可写,参数加上true
     * 3. 返回该token
     * 
     * @param ids 文件id
     *
     * @param writeable 是否可写
     *
     * @param ttl token的有效时间,单位秒
     *
     * @return token字符串
     *
     * @tables fs_file */
  java.lang.String getToken(java.util.List<java.lang.Long> ids, boolean writeable, int ttl) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 获取业务文件的访问token,通过url携带这个token实现文件的自定义权限
     *
     * 1. 用tokenService创建一个有效期为ttl的token (详见tokenService的createTokenEx)
     * 2. 用tokenService在该token上绑定参数列表 (详见tokenService的bindListParam)
     *    2.1 多个owner
     *    2.2 若可写,参数加上true
     * 3. 返回该token
     *
     * @param bizKey 业务名
     *
     * @param owners 所有者列表
     *
     * @param writeable 是否可写
     *
     * @param ttl token的有效时间,单位秒
     *
     * @return 业务token字符串
     *
     * @tables fs_file */
  java.lang.String getBizToken(java.lang.String bizKey, java.util.List<java.lang.String> owners, boolean writeable, int ttl) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 绑定文件的读取权限到会话session
     * 1.遍历文件编号,将他们以 'fs'+文件编号 为key,'T'为value放入一个map
     * 2.调用identityService的setSessionAttributes方法进行绑定(详见identityService)
     *
     * @param sessionId 会话id
     *
     * @param ids 文件id列表 */
  java.lang.Void bindSession(java.lang.String sessionId, java.util.List<java.lang.Long> ids) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 取消绑定文件的读取权限到会话session
     * 
     * 1.遍历文件编号,将他们以 'fs'+文件编号 为key,'T'为value放入一个map
     * 2.调用identityService的removeSessionAttributes方法取消绑定(详见identityService)
     * 
     * @param sessionId 会话id
     *
     * @param ids 文件id列表 */
  java.lang.Void unbindSession(java.lang.String sessionId, java.util.List<java.lang.Long> ids) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 获取一个文件
     * 
     * 1.仅获取数据库中的一个文件对象
     *
     * @param id 文件id
     *
     * @return 文件
     *
     * @tables fs_file */
  org.bear.api.fs.File getFile(long id) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 根据id批量获取文件
     * 
     * @param id 文件id列表
     *
     * @return 文件map
     *
     * @tables fs_file */
  java.util.Map<java.lang.String,org.bear.api.fs.File> getFileMap(java.util.List<java.lang.Long> ids) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 获取某个业务对象关联的文件
     * 例如用户的头像可以用getSingleFile(SPACE_AVATAR, "888")来获取888用户的头像文件信息
     *
     * @param bizKey 业务名
     *
     * @param owner 所有者
     *
     * @return 文件
     *
     * @tables fs_file */
  org.bear.api.fs.File getSingleFile(java.lang.String bizKey, java.lang.String owner) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 获取某个业务对象关联的文件,例如要获取某个帖子相关的附件,,按文件上传倒序排序
     *
     * @param bizKey 业务名
     *
     * @param owner 所有者
     *
     * @return 文件列表
     *
     * @tables fs_file */
  java.util.List<org.bear.api.fs.File> getFiles(java.lang.String bizKey, java.lang.String owner) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 根据owner列表批量获取某个业务对象关联的文件
     *
     * @param bizKey 业务名
     *
     * @param owners 所有者列表
     *
     * @return 文件列表map
     *
     * @tables fs_file */
  java.util.Map<java.lang.String,java.util.List<org.bear.api.fs.File>> batchGetFiles(java.lang.String bizKey, java.util.List<java.lang.String> owners) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 根据多个bizKey,多个owner获取文件,格式map<bizKey, set<owner>>
     *
     * @param ownersMap 嵌套map,map<bizKey, set<owner>>
     *
     * @param owners 所有者列表
     *
     * @return 嵌套map,map<bizKey, map<owner, list<File>>>
     *
     * @tables fs_file */
  java.util.Map<java.lang.String,java.util.Map<java.lang.String,java.util.List<org.bear.api.fs.File>>> batchGetFilesEx(java.util.Map<java.lang.String,java.util.List<java.lang.String>> ownersMap) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 获取某个文件的加密访问id
     * 
     * 1. 将id和系统时间和有效期,以某种形式组合,并通过加密算法加密后形成的字符串
     * 
     * @param id 文件id
     *
     * @param ttl 加密id的有效时间,单位秒，0为不限制
     *
     * @return 加密的id
     *
     * @tables fs_file */
  java.lang.String getEncryptedId(long id, int ttl) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 批量获取文件的加密访问
     * 
     * 1.同getEncryptedId
     * 
     * @param ids 文件id列表
     *
     * @param ttl 加密id的有效时间,单位秒，0为不限制
     *
     * @return 加密的id列表
     *
     * @tables fs_file */
  java.util.Map<java.lang.String,java.lang.String> getEncryptedIds(java.util.List<java.lang.Long> ids, int ttl) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 根据加密的id获取文件
     * 
     * 1. 根据加密规则解密出文件编号
     * 2. 根据文件编号从数据库中获取文件对象
     *
     * @param encryptedId 加密的id
     *
     * @return 文件
     *
     * @tables fs_file */
  org.bear.api.fs.File getFileByEncryptedId(java.lang.String encryptedId) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 批量根据加密的id获取文件
     * 
     * 1.同getFileByEncryptedId
     *
     * @param encryptedIds 加密的id列表
     *
     * @return 文件map
     *
     * @tables fs_file */
  java.util.Map<java.lang.String,org.bear.api.fs.File> getFileMapByEncryptedId(java.util.List<java.lang.String> encryptedIds) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;
  /** * 获取某个用户在目标业务的所有文件,如果业务为空则返回所有业务文件,按文件上传倒序排序
     *
     * @param bizKey 业务名 为空则忽略此条件
     *
     * @param owner 所有者 为空则忽略此条件
     *
     * @param userId 用户id
     *
     * @param start 开始位置
     *
     * @param size 获取个数
     *
     * @return 文件列表分页对象
     *
     * @tables fs_file */
  org.bear.api.fs.FilePage getUserFiles(java.lang.String bizKey, java.lang.String owner, long userId, int start, int size) throws org.apache.avro.AvroRemoteException, org.bear.api.type.GlobalException;

  @SuppressWarnings("all")
  public interface Callback extends FileStoreService {
    public static final org.apache.avro.Protocol PROTOCOL = org.bear.api.fs.FileStoreService.PROTOCOL;
    /** * 保存一个文件,当id为空时则为新建
     * 
     * 1. 若id不为空,获取id对应的file对象,设置传入的新属性后更新 (可更新owner,userId,name,scope,data属性)
     * 2. 若id为空,则新建一个file对象
     *
     * @param file 待保存的文件信
     *
     * @return 包含id的文件
     *
     * @tables fs_file */
    void saveFile(org.bear.api.fs.File file, org.apache.avro.ipc.Callback<org.bear.api.fs.File> callback) throws java.io.IOException;
    /** * 批量删除文件
     * 1. 批量将对应的数据库记录的status属性设置成Status.DELETED(逻辑删除)
     * 2. 真实文件不做删除
     * 
     * @param ids 文件id列表
     *
     * @tables fs_file */
    void removeFiles(java.util.List<java.lang.Long> ids, org.apache.avro.ipc.Callback<java.lang.Void> callback) throws java.io.IOException;
    /** * 批量删除和某个所有者相关联的所有文件
     * 1. 批量将对应的数据库记录的status属性设置成Status.DELETED(逻辑删除)
     * 2. 真实文件不做删除
     * 
     * @param bizKey 业务名
     *
     * @param owner 所有者
     *
     * @tables fs_file */
    void removeFilesByOwner(java.lang.String bizKey, java.lang.String owner, org.apache.avro.ipc.Callback<java.lang.Void> callback) throws java.io.IOException;
    /** * 将二进制内容写入到目标文件的指定位置
     * 
     * 1. 根据文件编号获取数据库中的文件记录
     * 2. 根据文件选择存储对象(storage)
     * 	  2.1 file对象获取storage属性值(系统在初始化时默认配置了唯一一个id为s1的sanyuan.any123.filestore.fs.FileSystemStorage,它的capability=-1,enable=true,存储基本路径directory配置为application.properties的storage1.path)
     *        若属性值未设置,遍历已有的storages列表,如果storage.isAvailable(如果是enable且,capability小于0或used大于capability),则选择这个storage
     *        若属性值已设置(该值可以为多个存储id以逗号分隔连接而成),则分隔成id列表,遍历已有storages的map(key为storage的id,value为storage),匹配第一个有效的storage(同上storage.isAvaliable)
     * 3. 获取file的key(fs-加上文件编号)
     * 4. 把这个key进行md5加密,'加密结果前两位/加密结果第三、四位/加密结果',作为文件的子路径
     * 5. 如果storage配置了useXsendfile为true的话,子路径前加上'/文件编号/'组成xpath
     * 6. 检查并创建这个文件
     * 	  6.1 若该路径下文件已存在,则跳过
     *    6.2 若文件不存在,检查并创建父文件路径,创建该文件
     * 7. 写入从起始位置开始,写入一定长度的二进制文件
     * 8. 文件设置大小信息
     * 9. 更新数据库中的文件信息
     *  
     * @param id 文件id
     *
     * @param binary 二进制内容
     *
     * @param position 起始位置
     *
     * @param binary 二进制内容
     *
     * @throws FsException <ul>
     *     <li>201 io错误</li>
     *     <li>202 文件未找到</li>
     * </ul>
     *
     * @tables fs_file */
    void writeFile(long id, java.nio.ByteBuffer bytes, int position, org.apache.avro.ipc.Callback<java.lang.Void> callback) throws java.io.IOException;
    /** * 从目标文件中读取内容
     * 
     * 1. 同writeFile逻辑一致,获取文件存放路径
     * 2. 根据路径找到文件,读取文件起始位置开始,一定长度的二进制流
     * 
     *
     * @param id 文件id
     *
     * @param position 起始位置
     *
     * @param count 要读取的长度
     *
     * @return 读取的二进制内容
     *
     * @throws FsException <ul>
     *     <li>201 io错误</li>
     *     <li>202 文件未找到</li>
     * </ul>
     *
     * @tables fs_file */
    void readFile(long id, int position, int count, org.apache.avro.ipc.Callback<java.nio.ByteBuffer> callback) throws java.io.IOException;
    /** * 变换一个图片
     *  
     * 涉及到的参数
     * 
     *  
     * 1. 同writeFile逻辑一致,获取文件存放路径
     * 2. 如果文件是图片(后缀为"gif", "bmp", "jpg", "jpeg", "png"之一),则进行后续操作(本系统由AwtImageTransform进行图片相关操作)
     * 3. 若操作为缩放,则调用图片缩放接口,由宽度为限制条件(若实际图片宽度>目标宽度,则缩放比例为目标宽度/实际宽度),等比缩放
     * 4. 若操作为裁剪,则调用图片裁剪接口,截取从图片左上角为坐标轴原点,第四象限中(left,-top)这个点为起点,x轴正方向width宽度,y轴反方向height高度组成的矩形
     * 5. 若操作为翻转,则选取从图片左上角为坐标轴原点,第四象限中(left,-top)这个点为旋转中心点,以逆时针方向旋转一定角度
     * 6. 操作完成后,更新数据库中文件的大小
     * 
     * @param id 文件id
     *
     * @param actions 变换操作列表
     *
     * @tables fs_file
     * */
    void transformImage(long id, java.util.List<org.bear.api.fs.Action> actions, org.apache.avro.ipc.Callback<java.lang.Void> callback) throws java.io.IOException;
    /** * 获取一个文件的访问token,通过url携带这个token实现文件的自定义权限
     * 1. 用tokenService创建一个有效期为ttl的token (详见tokenService的createTokenEx)
     * 2. 用tokenService在该token上绑定参数列表 (详见tokenService的bindListParam)
     *    2.1 多个id
     *    2.2 若可写,参数加上true
     * 3. 返回该token
     * 
     * @param ids 文件id
     *
     * @param writeable 是否可写
     *
     * @param ttl token的有效时间,单位秒
     *
     * @return token字符串
     *
     * @tables fs_file */
    void getToken(java.util.List<java.lang.Long> ids, boolean writeable, int ttl, org.apache.avro.ipc.Callback<java.lang.String> callback) throws java.io.IOException;
    /** * 获取业务文件的访问token,通过url携带这个token实现文件的自定义权限
     *
     * 1. 用tokenService创建一个有效期为ttl的token (详见tokenService的createTokenEx)
     * 2. 用tokenService在该token上绑定参数列表 (详见tokenService的bindListParam)
     *    2.1 多个owner
     *    2.2 若可写,参数加上true
     * 3. 返回该token
     *
     * @param bizKey 业务名
     *
     * @param owners 所有者列表
     *
     * @param writeable 是否可写
     *
     * @param ttl token的有效时间,单位秒
     *
     * @return 业务token字符串
     *
     * @tables fs_file */
    void getBizToken(java.lang.String bizKey, java.util.List<java.lang.String> owners, boolean writeable, int ttl, org.apache.avro.ipc.Callback<java.lang.String> callback) throws java.io.IOException;
    /** * 绑定文件的读取权限到会话session
     * 1.遍历文件编号,将他们以 'fs'+文件编号 为key,'T'为value放入一个map
     * 2.调用identityService的setSessionAttributes方法进行绑定(详见identityService)
     *
     * @param sessionId 会话id
     *
     * @param ids 文件id列表 */
    void bindSession(java.lang.String sessionId, java.util.List<java.lang.Long> ids, org.apache.avro.ipc.Callback<java.lang.Void> callback) throws java.io.IOException;
    /** * 取消绑定文件的读取权限到会话session
     * 
     * 1.遍历文件编号,将他们以 'fs'+文件编号 为key,'T'为value放入一个map
     * 2.调用identityService的removeSessionAttributes方法取消绑定(详见identityService)
     * 
     * @param sessionId 会话id
     *
     * @param ids 文件id列表 */
    void unbindSession(java.lang.String sessionId, java.util.List<java.lang.Long> ids, org.apache.avro.ipc.Callback<java.lang.Void> callback) throws java.io.IOException;
    /** * 获取一个文件
     * 
     * 1.仅获取数据库中的一个文件对象
     *
     * @param id 文件id
     *
     * @return 文件
     *
     * @tables fs_file */
    void getFile(long id, org.apache.avro.ipc.Callback<org.bear.api.fs.File> callback) throws java.io.IOException;
    /** * 根据id批量获取文件
     * 
     * @param id 文件id列表
     *
     * @return 文件map
     *
     * @tables fs_file */
    void getFileMap(java.util.List<java.lang.Long> ids, org.apache.avro.ipc.Callback<java.util.Map<java.lang.String,org.bear.api.fs.File>> callback) throws java.io.IOException;
    /** * 获取某个业务对象关联的文件
     * 例如用户的头像可以用getSingleFile(SPACE_AVATAR, "888")来获取888用户的头像文件信息
     *
     * @param bizKey 业务名
     *
     * @param owner 所有者
     *
     * @return 文件
     *
     * @tables fs_file */
    void getSingleFile(java.lang.String bizKey, java.lang.String owner, org.apache.avro.ipc.Callback<org.bear.api.fs.File> callback) throws java.io.IOException;
    /** * 获取某个业务对象关联的文件,例如要获取某个帖子相关的附件,,按文件上传倒序排序
     *
     * @param bizKey 业务名
     *
     * @param owner 所有者
     *
     * @return 文件列表
     *
     * @tables fs_file */
    void getFiles(java.lang.String bizKey, java.lang.String owner, org.apache.avro.ipc.Callback<java.util.List<org.bear.api.fs.File>> callback) throws java.io.IOException;
    /** * 根据owner列表批量获取某个业务对象关联的文件
     *
     * @param bizKey 业务名
     *
     * @param owners 所有者列表
     *
     * @return 文件列表map
     *
     * @tables fs_file */
    void batchGetFiles(java.lang.String bizKey, java.util.List<java.lang.String> owners, org.apache.avro.ipc.Callback<java.util.Map<java.lang.String,java.util.List<org.bear.api.fs.File>>> callback) throws java.io.IOException;
    /** * 根据多个bizKey,多个owner获取文件,格式map<bizKey, set<owner>>
     *
     * @param ownersMap 嵌套map,map<bizKey, set<owner>>
     *
     * @param owners 所有者列表
     *
     * @return 嵌套map,map<bizKey, map<owner, list<File>>>
     *
     * @tables fs_file */
    void batchGetFilesEx(java.util.Map<java.lang.String,java.util.List<java.lang.String>> ownersMap, org.apache.avro.ipc.Callback<java.util.Map<java.lang.String,java.util.Map<java.lang.String,java.util.List<org.bear.api.fs.File>>>> callback) throws java.io.IOException;
    /** * 获取某个文件的加密访问id
     * 
     * 1. 将id和系统时间和有效期,以某种形式组合,并通过加密算法加密后形成的字符串
     * 
     * @param id 文件id
     *
     * @param ttl 加密id的有效时间,单位秒，0为不限制
     *
     * @return 加密的id
     *
     * @tables fs_file */
    void getEncryptedId(long id, int ttl, org.apache.avro.ipc.Callback<java.lang.String> callback) throws java.io.IOException;
    /** * 批量获取文件的加密访问
     * 
     * 1.同getEncryptedId
     * 
     * @param ids 文件id列表
     *
     * @param ttl 加密id的有效时间,单位秒，0为不限制
     *
     * @return 加密的id列表
     *
     * @tables fs_file */
    void getEncryptedIds(java.util.List<java.lang.Long> ids, int ttl, org.apache.avro.ipc.Callback<java.util.Map<java.lang.String,java.lang.String>> callback) throws java.io.IOException;
    /** * 根据加密的id获取文件
     * 
     * 1. 根据加密规则解密出文件编号
     * 2. 根据文件编号从数据库中获取文件对象
     *
     * @param encryptedId 加密的id
     *
     * @return 文件
     *
     * @tables fs_file */
    void getFileByEncryptedId(java.lang.String encryptedId, org.apache.avro.ipc.Callback<org.bear.api.fs.File> callback) throws java.io.IOException;
    /** * 批量根据加密的id获取文件
     * 
     * 1.同getFileByEncryptedId
     *
     * @param encryptedIds 加密的id列表
     *
     * @return 文件map
     *
     * @tables fs_file */
    void getFileMapByEncryptedId(java.util.List<java.lang.String> encryptedIds, org.apache.avro.ipc.Callback<java.util.Map<java.lang.String,org.bear.api.fs.File>> callback) throws java.io.IOException;
    /** * 获取某个用户在目标业务的所有文件,如果业务为空则返回所有业务文件,按文件上传倒序排序
     *
     * @param bizKey 业务名 为空则忽略此条件
     *
     * @param owner 所有者 为空则忽略此条件
     *
     * @param userId 用户id
     *
     * @param start 开始位置
     *
     * @param size 获取个数
     *
     * @return 文件列表分页对象
     *
     * @tables fs_file */
    void getUserFiles(java.lang.String bizKey, java.lang.String owner, long userId, int start, int size, org.apache.avro.ipc.Callback<org.bear.api.fs.FilePage> callback) throws java.io.IOException;
  }
}